{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/web/storage/",
    "result": {"data":{"cur":{"id":"452cdc53-cb31-548a-8275-82a8237332fc","html":"<h2 id=\"web-storage\" style=\"position:relative;\"><a href=\"#web-storage\" aria-label=\"web storage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Storage</h2>\n<p>HTML5에는 웹의 데이터를 클라이언트에 저장할 수 있는 새로운 자료구조인 Web Storage 스펙이 포함되어 있다. <br /><br />\r\nWeb Storage의 개념은 key/value 쌍으로 데이터를 저장하고 key를 기반으로 데이터를 조회하는 패턴이다. <br /><br />\r\n영구저장소(LocalStorage)와 임시저장소(SessionStorage)를 따로 두어 데이터의 지속성을 구분할 수 있어 환경에 맞게 선택이 가능하다. <br /><br /></p>\n<p>Web Storage는 기존 Cookie와 매우 유사한 개념이다. <br /><br />\r\n몇 가지 쿠키의 단점을 보완하기 위해 도입되었다. <br /><br /></p>\n<h3 id=\"web-storage와-cookie의-차이점\" style=\"position:relative;\"><a href=\"#web-storage%EC%99%80-cookie%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"web storage와 cookie의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Storage와 Cookie의 차이점</h3>\n<ul>\n<li>쿠키는 매번 서버로 전송된다.</li>\n</ul>\n<p>웹사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송된다.</p>\n<ul>\n<li>단순 문자열을 넘어 객체정보를 저장할 수 있다.</li>\n</ul>\n<p>문자열 기반 데이터이 외에 구조화된 객체를 저장할 수 있다.</p>\n<ul>\n<li>제한 용량이 쿠키에 비해 자유롭다.</li>\n</ul>\n<p>쿠키는 개수와 용량에 제한이 있다. 하나의 사이트에서 저장할 수 있는 최대 쿠키 수는 20개, 크기는 4KB이다.<br>\n이에 반해 Web Storage는 브라우저에 따라 다를 수 있지만 보통 5MB 이상이다.</p>\n<ul>\n<li>영구 데이터 저장이 가능하다.</li>\n</ul>\n<p>쿠키는 만료일자를 지정하게 되어 있어 언젠가 제거된다. 만료일자를 지정하지 않으면 세션 쿠키가 된다. 영구 쿠키를 원한다면 만료일자를 굉장히 멀게 설정하여 해결할 수 있다.<br>\nWeb Storage는 만료 기간의 설정이 없다. 즉, 한번 저장한 데이터는 영구적으로 존재한다.</p>\n<br />\n<h3 id=\"localstorage와-sessionstorage\" style=\"position:relative;\"><a href=\"#localstorage%EC%99%80-sessionstorage\" aria-label=\"localstorage와 sessionstorage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LocalStorage와 SessionStorage</h3>\n<p>Web Storage는 데이터의 지속성과 관련하여 두 가지 용도의 저장소를 제공한다.  <br />\r\n기본적으로 Web Storage는 쿠키와 마찬가지로 사이트의 도메인 단위로 접근이 제한된다.<br>\n예를 들어 A도메인에서 저장한 데이터는 B 도메인에서 조회할 수 없다. (보안적인 측면)</p>\n<h4 id=\"localstorage\" style=\"position:relative;\"><a href=\"#localstorage\" aria-label=\"localstorage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LocalStorage</h4>\n<p>저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능하다. 앞서 말한대로 도메인마다 별도로 로컬 스토리지가 생성된다. Windows 전역 객체의 LocalStorage라는 컬렉션을 통해 저장과 조회가 이루어진다.</p>\n<h4 id=\"sessionstorage\" style=\"position:relative;\"><a href=\"#sessionstorage\" aria-label=\"sessionstorage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SessionStorage</h4>\n<p>SessionStorage는 데이터의 지속성과 액세스 범위에 특수한 제한이 존재한다. SessionStorage는 windows 전역 객체의 sessionStorage라는 컬렉션을 통해 저장과 조회가 이루어진다.</p>\n<p>Refference: <a href=\"https://velog.io/@ejchaid/localstorage-sessionstorage-cookie%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">https://velog.io/@ejchaid/localstorage-sessionstorage-cookie%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90</a></p>\n<p><br /><br /><br /></p>","excerpt":"Web Storage HTML5에는 웹의 데이터를 클라이언트에 저장할 수 있는 새로운 자료구조인 Web Storage 스펙이 포함되어 있다. \r\nWeb Storage의 개념은 key/value 쌍으로 데이터를 저장하고 key를 기반으로 데이터를 조회하는 패턴이다. \r\n영구저장소(LocalStorage)와 임시저장소(SessionStorage)를 따로 두어 데이터의 지속성을 구분할 수 있어 환경에 맞게 선택이 가능하다.  Web Storage는 기존 Cookie와 매우 유사한 개념이다. \r\n몇 가지 쿠키의 단점을 보완하기 위해 도입되었다.  Web Storage와 Cookie의 차이점 쿠키는 매번 서버로 전송된다. 웹사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송된다. 단순 문자열을 넘어 객체정보를 저장할 수 있다. 문자열 기반 데이터이 외에 구조화된 객체를 저장할 수 있다. 제한 용량이 쿠키에 비해 자유롭다. 쿠키는 개수와 용량에 제한이 있다. 하나…","frontmatter":{"date":"December 22, 2021","title":"LocalStorage, SessionStorage, Cookie","categories":"tech-interview web","author":"Covy","emoji":"🔍"},"fields":{"slug":"/web/storage/"}},"next":{"id":"3087bf78-2b89-5e19-9df0-0be20610e146","html":"<h2 id=\"side-effect-란\" style=\"position:relative;\"><a href=\"#side-effect-%EB%9E%80\" aria-label=\"side effect 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side Effect 란?</h2>\n<p>React 컴포넌트가 화면에 1차로 렌더링된 이후에 <U>비동기로 처리되어야 하는 부수적인 효과들</U>  <br /><br /></p>\n<h3 id=\"비동기로-처리되어야-하는-이유\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0%EB%A1%9C-%EC%B2%98%EB%A6%AC%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"비동기로 처리되어야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기로 처리되어야 하는 이유?</h3>\n<p>데이터를 가져오려고 외부 API를 호출할 때, 일단 화면에 렌더링할 수 있는 것은 1차로 렌더링하고 실제 데이터는 비동기로 가져오는 것이 권장된다.<br>\n이유는 연동된 API가 응답이 늦거나 없을 때 데미지(사용자의 답답함)를 최소화 시켜 사용자 경험 측면에서 유리하기 때문이다.  <br /><br /></p>\n<h2 id=\"react-hooks-란\" style=\"position:relative;\"><a href=\"#react-hooks-%EB%9E%80\" aria-label=\"react hooks 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Hooks 란?</h2>\n<p>Hooks는 리액트 v16.8에 새로 도입된 기능이다. 함수형태의 컴포넌트에서 사용되는 몇가시 기술을 Hook이라고 부른다.<br>\n함수형 컴포넌트에서도 <U>상태 관리를 할 수 있는 useState</U>, 그리고 <U>렌더링 직후 작업을 설정하는 useEffect</U> 등의 기능을 제공한다.  <br /><br /></p>\n<h3 id=\"잘-사용하고-있던-클래스형-컴포넌트에서-함수형-컴포넌트로-바꾸는-이유\" style=\"position:relative;\"><a href=\"#%EC%9E%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8D%98-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EB%B0%94%EA%BE%B8%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"잘 사용하고 있던 클래스형 컴포넌트에서 함수형 컴포넌트로 바꾸는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잘 사용하고 있던 클래스형 컴포넌트에서 함수형 컴포넌트로 바꾸는 이유?</h3>\n<p>React를 배우는 데 있어서 클래스는 큰 진입장벽이었다. 코드의 재사용성과 코드 구성을 어렵게 만들고, this의 사용이나 이벤트 핸들러의 등록 등 기본적인 JS문법 사항을 알아야 다룰 수 있기 때문이다. 또한 클래스는 잘 축소되지 않고, reloading이 깨지기 쉽고 신뢰하기 어렵게 만든다. 따라서 react의 최신 기술들이 클래스형 컴포넌트에 효과적으로 적용되지 않았다.</p>\n<ol>\n<li>클래스의 문법이 어렵다.</li>\n<li>축소가 어렵다.</li>\n<li>reloading의 신뢰성이 떨어진다.</li>\n<li>최신 기술의 적용이 효과적이지 않다.</li>\n</ol>\n<p>-> <U>이러한 클래스의 단점들을 함수형 컴포넌트로 해결할 수 있다. 하지만 클래스 컴포넌트의 장점인 state 사용이나 life cycle을 직접 다루는 등의 기능을 사용하지 못한다. 이를 해결하기 위해 Hook이 등장하였다.</U> <br />( Hook을 사용하는 이유 )</p>\n<br />\n<h2 id=\"hooks의-종류\" style=\"position:relative;\"><a href=\"#hooks%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"hooks의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks의 종류</h2>\n<ol>\n<li>useState()</li>\n</ol>\n<ul>\n<li>함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해준다.</li>\n<li>해당 함수의 인자에는 상태의 기본값이 들어간다.</li>\n</ul>\n<ol start=\"2\">\n<li>useEffect()</li>\n</ol>\n<ul>\n<li>컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있다.</li>\n</ul>\n<ol start=\"3\">\n<li>useReducer()</li>\n</ol>\n<ul>\n<li>useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용한다.</li>\n<li>현재 상태, 업데이트를 위해 필요한 정보를 담은 액션 값을 전달받아 새로운 상태를 반환하는 함수이다. 반드시 불변성을 지켜줘야 한다.</li>\n<li>첫 번째 인자로 reducer 함수를 받고, 두 번째 인자로 해당 리듀서의 기본값을 넣어준다.</li>\n<li>이 Hook은 배열을 리턴하고, 첫 번째 인자가 상태고, 두 번째 인자가 dispatch 함수인 길이가 2인 배열을 리턴한다.</li>\n</ul>\n<ol start=\"4\">\n<li>useMemo()</li>\n</ol>\n<ul>\n<li>함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다.</li>\n<li>렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식이다.</li>\n</ul>\n<ol start=\"5\">\n<li>useCallback()</li>\n</ol>\n<ul>\n<li>useMemo와 비슷하다. 주로 렌더링 성능을 최적화해야 하는 상황에 사용한다. 이벤트 핸들러 함수를 필요할 때만 생성할 수 있다.</li>\n<li>첫 번째 인자에는 생성하고 싶은 함수를, 두 번째 인자에는 배열을 넣는다. 이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야 한다.</li>\n<li>함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시 두 번째 파라미터 안에 포함시켜 주어야 한다.</li>\n</ul>\n<ol start=\"6\">\n<li>useRef()</li>\n</ol>\n<ul>\n<li>함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 한다.</li>\n<li>useRef를 통해 만든 객체 안의 current 값이 실제 엘리먼트를 가리킨다.</li>\n</ul>\n<p><br /><br /></p>\n<p>Refference: <a href=\"https://devbirdfeet.tistory.com/52\">https://devbirdfeet.tistory.com/52</a> <br />\r\n                     \r\n<a href=\"https://lelana.tistory.com/146\">https://lelana.tistory.com/146</a></p>\n<p><br /><br /><br /></p>","frontmatter":{"date":"December 15, 2021","title":"React Hook","categories":"tech-interview react","author":"Covy","emoji":"🔍"},"fields":{"slug":"/react/hook/"}},"prev":{"id":"3260811c-9076-5608-9751-3798a6035aae","html":"<h2 id=\"웹-브라우저의-동작-순서\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%88%9C%EC%84%9C\" aria-label=\"웹 브라우저의 동작 순서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 브라우저의 동작 순서</h2>\n<ol>\n<li>사용자가 브라우저에 도메인 입력(ex. <a href=\"https://www.naver.com\">https://www.naver.com</a>)</li>\n<li>웹 브라우저는 DNS에 입력된 도메인의 IP 주소를 요청</li>\n<li>해당 IP주소에 해당하는 서버로 접근(이때, random sequence 번호를 가지고 접근)</li>\n<li>서버에서 브라우저에 번호에 1을 더하여 응답(random sequence + 1)</li>\n<li>브라우저에서 다시 서버에 1을 더하여 응답</li>\n<li>(3, 4, 5 과정을 3 Way-Handshake 라고 한다. 브라우저가 서버에게 자신의 존재를 알리고 -> 서버는 브라우저의 존재를 확인했다는 사실 + 자신의 존재를 알리는 신호를 브라우저에 보냄 -> 브라우저는 서버의 존재를 확인했다는 신호를 서버에 다시 보냄 ===> 위 세 과정을 통해 브라우저와 서버간의 TCP 연결이 성립된다.)</li>\n</ol>\n<h2 id=\"브라우저-렌더링-과정\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95\" aria-label=\"브라우저 렌더링 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링 과정</h2>\n<p><br /><br /><br /></p>\n<p>Refference <br />\r\n<a href=\"https://www.youtube.com/watch?v=FQHNg9gCWpg\">\r\n웹 브라우저의 동작 순서(유튜브)\r\n</a></p>","frontmatter":{"date":"May 03, 2022","title":"Web 브라우저의 동작 순서","categories":"tech-interview web","author":"Covy","emoji":"🔍"},"fields":{"slug":"/web/browser/"}},"site":{"siteMetadata":{"siteUrl":"https://eungbin.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/web/storage/","nextSlug":"/react/hook/","prevSlug":"/web/browser/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}